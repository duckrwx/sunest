{
  "language": "Solidity",
  "sources": {
    "contracts/ProofOfExistence.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ncontract ProofOfExistence {\n  mapping(bytes32 => address) public files;\n  mapping(address => bytes32[]) public users;\n\n  event Claimed(address indexed owner, bytes32 indexed file);\n  event Forfeited(address indexed owner, bytes32 indexed file);\n\n  error NotFileOwner();\n  error FileAlreadyClaimed();\n\n  modifier isOwner(bytes32 hash) {\n    address from = msg.sender;\n    if (files[hash] != from) revert NotFileOwner();\n    _;\n  }\n\n  modifier notClaimed(bytes32 hash) {\n    address from = msg.sender;\n    if (files[hash] != address(0)) revert FileAlreadyClaimed();\n    _;\n  }\n\n  function hasClaimed(bytes32 hash) public view returns (bool) {\n    address owner = files[hash];\n    return (owner != address(0));\n  }\n\n  function ownedFiles() public view returns (bytes32[] memory) {\n    address from = msg.sender;\n    return users[from];\n  }\n\n  function claim(bytes32 hash) public notClaimed(hash) returns (bool) {\n    address from = msg.sender;\n\n    // update storage files\n    files[hash] = from;\n\n    // update storage users\n    bytes32[] storage userFiles = users[from];\n    userFiles.push(hash);\n\n    emit Claimed(from, hash);\n    return true;\n  }\n\n  function forfeit(bytes32 hash) public isOwner(hash) returns (bool) {\n    address from = msg.sender;\n\n    // update storage files\n    delete files[hash];\n\n    // locate the index of the file going to be deleted.\n    bytes32[] storage userFiles = users[from];\n    uint32 delIdx = 0;\n    for (uint32 i = 0; i < userFiles.length; i++) {\n      if (userFiles[i] == hash) {\n        delIdx = i;\n        break;\n      }\n    }\n    // update storage users by swap-delete\n    if (delIdx != userFiles.length - 1) {\n      userFiles[delIdx] = userFiles[userFiles.length - 1];\n    }\n    // delete\n    userFiles.pop();\n\n    emit Forfeited(from, hash);\n    return true;\n  }\n}\n"
    },
    "contracts/Sunest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/*\n * Sunest – contrato simplificado para testes locais.\n * - Registro de microgrid (wallet Kaspa, preço, país, cidade)\n * - Envio de dados de geração (submitSensorData)\n * - Registro de nós verdes e troca automática de painel\n * - Consulta amigável por localização\n * - getMicrogridInfo devolve todos os dados + kWh atual + capacidade em GB\n * - Referência a ProofOfExistence (PoE) para registrar arquivos no futuro\n */\n\nimport \"./ProofOfExistence.sol\";\n\ncontract Sunest {\n    /*––––– CONSTs –––––*/\n    uint256 private constant KWH_PER_GB    = 5;   // 5 kWh ≅ 1 GB\n    uint256 private constant THRESHOLD_PCT = 30;  // % mínima de energia antes de migrar\n\n    /*––––– REFERÊNCIA PoE –––––*/\n    ProofOfExistence public poe;\n\n    constructor(address _poe) {\n        poe = ProofOfExistence(_poe);\n    }\n\n    /*––––– STRUCTS –––––*/\n    struct Microgrid {\n        address kaspaWallet;\n        uint256 energyPricePerOp;\n        string  country;\n        string  city;\n        bool    isActive;\n        address owner;\n    }\n\n    struct SensorRecord {\n        uint256 kWh;\n        uint256 timestamp;\n    }\n\n    struct Node {\n        address operator;\n        bytes32 currentMicrogridHash;\n        bool    isActive;\n        string  country;\n        string  city;\n        uint256 storedGB;\n    }\n\n    /*––––– STORAGE –––––*/\n    mapping(bytes32 => Microgrid)      public microgridByHash;\n    mapping(bytes32 => SensorRecord[]) public sensorHistory;\n    mapping(address  => Node)          public nodeByOperator;\n\n    bytes32[] public allMicrogridHashes;\n    address[] public allNodeOperators;\n\n    /*––––– EVENTS –––––*/\n    event MicrogridRegistered(bytes32 hash, address owner);\n    event SensorDataSubmitted(bytes32 hash, uint256 kWh, uint256 timestamp);\n    event NodeRegistered(address operator, bytes32 microgridHash);\n    event NodeSwitched(address operator, bytes32 newHash);\n    event NodeDeactivated(address operator);\n\n    /*––––– MICROGRID –––––*/\n    function registerMicrogrid(\n        address _kaspaWallet,\n        uint256 _energyPricePerOp,\n        string  memory _country,\n        string  memory _city\n    ) external {\n        bytes32 hash = keccak256(abi.encodePacked(_kaspaWallet, _country, _city));\n        require(microgridByHash[hash].kaspaWallet == address(0), \"Already registered\");\n\n        microgridByHash[hash] = Microgrid({\n            kaspaWallet:      _kaspaWallet,\n            energyPricePerOp: _energyPricePerOp,\n            country:          _country,\n            city:             _city,\n            isActive:         true,\n            owner:            msg.sender\n        });\n        allMicrogridHashes.push(hash);\n        emit MicrogridRegistered(hash, msg.sender);\n    }\n\n    /*––––– SENSOR DATA –––––*/\n    function submitSensorData(bytes32 hash, uint256 kWh) external {\n        Microgrid storage mg = microgridByHash[hash];\n        require(mg.isActive, \"Inactive microgrid\");\n        require(msg.sender == mg.owner || msg.sender == mg.kaspaWallet, \"Not authorised\");\n        require(kWh > 0, \"kWh must be > 0\");\n\n        sensorHistory[hash].push(SensorRecord(kWh, block.timestamp));\n        emit SensorDataSubmitted(hash, kWh, block.timestamp);\n    }\n\n    function latestSensor(bytes32 hash) public view returns (SensorRecord memory) {\n        uint len = sensorHistory[hash].length;\n        require(len > 0, \"No data\");\n        return sensorHistory[hash][len - 1];\n    }\n\n    /*––––– NODE –––––*/\n    function registerNode(\n        bytes32 microgridHash,\n        string  memory country,\n        string  memory city,\n        uint256 initialGB\n    ) external {\n        require(nodeByOperator[msg.sender].operator == address(0), \"Node exists\");\n        require(microgridByHash[microgridHash].isActive, \"Inactive microgrid\");\n\n        nodeByOperator[msg.sender] = Node({\n            operator:             msg.sender,\n            currentMicrogridHash: microgridHash,\n            isActive:             true,\n            country:              country,\n            city:                 city,\n            storedGB:             initialGB\n        });\n        allNodeOperators.push(msg.sender);\n        emit NodeRegistered(msg.sender, microgridHash);\n    }\n\n    /* Troca ou desativa se energia < 30 % */\n    function switchIfNeeded() external {\n        Node storage nd = nodeByOperator[msg.sender];\n        require(nd.isActive, \"Node inactive\");\n\n        uint256 required = nd.storedGB * KWH_PER_GB;\n        SensorRecord memory curr = latestSensor(nd.currentMicrogridHash);\n\n        if (curr.kWh * 100 < required * THRESHOLD_PCT) {\n            bytes32 best;\n            for (uint i = 0; i < allMicrogridHashes.length; i++) {\n                bytes32 h = allMicrogridHashes[i];\n                Microgrid memory mg = microgridByHash[h];\n                if (!mg.isActive) continue;\n                if (\n                    keccak256(bytes(mg.country)) == keccak256(bytes(nd.country)) &&\n                    keccak256(bytes(mg.city))    == keccak256(bytes(nd.city))\n                ) {\n                    SensorRecord memory s = latestSensor(h);\n                    if (s.kWh >= required) { best = h; break; }\n                }\n            }\n            if (best != bytes32(0)) {\n                nd.currentMicrogridHash = best;\n                emit NodeSwitched(msg.sender, best);\n            } else {\n                nd.isActive = false;\n                emit NodeDeactivated(msg.sender);\n            }\n        }\n    }\n\n    /*––––– VIEW HELPERS –––––*/\n\n    /// Lista microgrids de uma cidade retornando vetores paralelos\n    function microgridsByLocation(string calldata country, string calldata city)\n        external\n        view\n        returns (\n            bytes32[] memory hashes,\n            address[] memory wallets,\n            uint256[] memory prices,\n            bool[]    memory active,\n            uint256[] memory latestKWh,\n            uint256[] memory capacityGB\n        )\n    {\n        uint count;\n        for (uint i = 0; i < allMicrogridHashes.length; i++) {\n            Microgrid storage mg = microgridByHash[allMicrogridHashes[i]];\n            if (\n                keccak256(bytes(mg.country)) == keccak256(bytes(country)) &&\n                keccak256(bytes(mg.city))    == keccak256(bytes(city))\n            ) count++;\n        }\n\n        hashes      = new bytes32[](count);\n        wallets     = new address[](count);\n        prices      = new uint256[](count);\n        active      = new bool[](count);\n        latestKWh   = new uint256[](count);\n        capacityGB  = new uint256[](count);\n\n        uint idx;\n        for (uint i = 0; i < allMicrogridHashes.length; i++) {\n            bytes32 h = allMicrogridHashes[i];\n            Microgrid storage mg = microgridByHash[h];\n            if (\n                keccak256(bytes(mg.country)) == keccak256(bytes(country)) &&\n                keccak256(bytes(mg.city))    == keccak256(bytes(city))\n            ) {\n                hashes[idx]  = h;\n                wallets[idx] = mg.kaspaWallet;\n                prices[idx]  = mg.energyPricePerOp;\n                active[idx]  = mg.isActive;\n\n                uint len = sensorHistory[h].length;\n                uint kwh = (len > 0) ? sensorHistory[h][len - 1].kWh : 0;\n                latestKWh[idx]  = kwh;\n                capacityGB[idx] = kwh / KWH_PER_GB;\n                idx++;\n            }\n        }\n    }\n\n    function listMicrogrids() external view returns (bytes32[] memory) {\n        return allMicrogridHashes;\n    }\n\n    /// Info completa + energia atual e capacidade\n    function getMicrogridInfo(bytes32 hash)\n        external\n        view\n        returns (\n            address kaspaWallet,\n            uint256 pricePerOp,\n            string  memory country,\n            string  memory city,\n            bool    active,\n            uint256 latestKWh,\n            uint256 capacityGB\n        )\n    {\n        Microgrid storage mg = microgridByHash[hash];\n        require(mg.kaspaWallet != address(0), \"Unknown microgrid\");\n        uint len = sensorHistory[hash].length;\n        uint kwh = (len > 0) ? sensorHistory[hash][len - 1].kWh : 0;\n        return (\n            mg.kaspaWallet,\n            mg.energyPricePerOp,\n            mg.country,\n            mg.city,\n            mg.isActive,\n            kwh,\n            kwh / KWH_PER_GB\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}