{
  "language": "Solidity",
  "sources": {
    "contracts/ProofOfExistence.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ncontract ProofOfExistence {\n  mapping(bytes32 => address) public files;\n  mapping(address => bytes32[]) public users;\n\n  event Claimed(address indexed owner, bytes32 indexed file);\n  event Forfeited(address indexed owner, bytes32 indexed file);\n\n  error NotFileOwner();\n  error FileAlreadyClaimed();\n\n  modifier isOwner(bytes32 hash) {\n    address from = msg.sender;\n    if (files[hash] != from) revert NotFileOwner();\n    _;\n  }\n\n  modifier notClaimed(bytes32 hash) {\n    address from = msg.sender;\n    if (files[hash] != address(0)) revert FileAlreadyClaimed();\n    _;\n  }\n\n  function hasClaimed(bytes32 hash) public view returns (bool) {\n    address owner = files[hash];\n    return (owner != address(0));\n  }\n\n  function ownedFiles() public view returns (bytes32[] memory) {\n    address from = msg.sender;\n    return users[from];\n  }\n\n  function claim(bytes32 hash) public notClaimed(hash) returns (bool) {\n    address from = msg.sender;\n\n    // update storage files\n    files[hash] = from;\n\n    // update storage users\n    bytes32[] storage userFiles = users[from];\n    userFiles.push(hash);\n\n    emit Claimed(from, hash);\n    return true;\n  }\n\n  function forfeit(bytes32 hash) public isOwner(hash) returns (bool) {\n    address from = msg.sender;\n\n    // update storage files\n    delete files[hash];\n\n    // locate the index of the file going to be deleted.\n    bytes32[] storage userFiles = users[from];\n    uint32 delIdx = 0;\n    for (uint32 i = 0; i < userFiles.length; i++) {\n      if (userFiles[i] == hash) {\n        delIdx = i;\n        break;\n      }\n    }\n    // update storage users by swap-delete\n    if (delIdx != userFiles.length - 1) {\n      userFiles[delIdx] = userFiles[userFiles.length - 1];\n    }\n    // delete\n    userFiles.pop();\n\n    emit Forfeited(from, hash);\n    return true;\n  }\n}\n"
    },
    "contracts/Sunest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title Sunest\n * @notice Contrato para registrar e gerenciar microgrids de energia solar e nós consumidores.\n * @dev Versão otimizada com busca de microgrids por localização para maior eficiência de gás.\n */\n\nimport \"./ProofOfExistence.sol\";\n\ncontract Sunest {\n    /*––––– CONSTANTES –––––*/\n    uint256 private constant KWH_PER_GB = 5;      // 5 kWh equivalem a 1 GB de capacidade de processamento/armazenamento.\n    uint256 private constant THRESHOLD_PCT = 30;  // Porcentagem mínima de energia necessária antes de um nó precisar trocar de microgrid.\n\n    /*––––– REFERÊNCIA A OUTROS CONTRATOS –––––*/\n    ProofOfExistence public poe;\n\n    /*––––– STRUCTS –––––*/\n\n    struct Microgrid {\n        address walletMetamask;   // Endereço da carteira do operador da microgrid.\n        uint256 energyPricePerOp; // Preço da energia.\n        string  country;          // País da microgrid.\n        string  city;             // Cidade da microgrid.\n        bool    isActive;         // Status da microgrid.\n        address owner;            // Dono do registro no contrato.\n    }\n\n    struct SensorRecord {\n        uint256 kWh;              // Energia gerada (em kWh).\n        uint256 timestamp;        // Timestamp do registro.\n    }\n\n    struct Node {\n        address operator;             // Endereço do operador do nó.\n        bytes32 currentMicrogridHash; // Hash da microgrid à qual o nó está conectado.\n        bool    isActive;             // Status do nó.\n        string  country;              // País do nó.\n        string  city;                 // Cidade do nó.\n        uint256 storedGB;             // Capacidade de armazenamento/processamento do nó em GB.\n    }\n\n    /*––––– VARIÁVEIS DE ESTADO (STORAGE) –––––*/\n\n    // Mapeamentos primários para acesso direto por hash ou endereço.\n    mapping(bytes32 => Microgrid) public microgridByHash;\n    mapping(bytes32 => SensorRecord[]) public sensorHistory;\n    mapping(address => Node) public nodeByOperator;\n\n    // Listas para iteração e descoberta.\n    bytes32[] public allMicrogridHashes;\n    address[] public allNodeOperators;\n\n    // OTIMIZAÇÃO: Mapeamento para buscar microgrids por localização de forma eficiente.\n    mapping(bytes32 => bytes32[]) public microgridsByLocationHash;\n\n    /*––––– EVENTOS –––––*/\n\n    event MicrogridRegistered(bytes32 indexed hash, address indexed owner, string country, string city);\n    event SensorDataSubmitted(bytes32 indexed hash, uint256 kWh, uint256 timestamp);\n    event NodeRegistered(address indexed operator, bytes32 indexed microgridHash);\n    event NodeSwitched(address indexed operator, bytes32 oldHash, bytes32 newHash);\n    event NodeDeactivated(address indexed operator);\n\n    /*––––– CONSTRUTOR –––––*/\n\n    constructor(address _poeAddress) {\n        poe = ProofOfExistence(_poeAddress);\n    }\n\n    /*––––– FUNÇÕES DE MICROGRID –––––*/\n\n    /**\n     * @notice Registra uma nova microgrid no sistema.\n     * @dev Gera um hash único para a microgrid e a indexa por localização para buscas futuras.\n     * @param _walletMetamask O endereço da carteira do operador da microgrid.\n     * @param _energyPricePerOp O preço da energia por operação.\n     * @param _country O país onde a microgrid está localizada.\n     * @param _city A cidade onde a microgrid está localizada.\n     */\n    function registerMicrogrid(\n        address _walletMetamask,\n        uint256 _energyPricePerOp,\n        string memory _country,\n        string memory _city\n    ) external {\n        bytes32 hash = keccak256(abi.encodePacked(_walletMetamask, _country, _city));\n        require(microgridByHash[hash].owner == address(0), \"Microgrid: Ja registrada\");\n\n        microgridByHash[hash] = Microgrid({\n            walletMetamask:   _walletMetamask,\n            energyPricePerOp: _energyPricePerOp,\n            country:          _country,\n            city:             _city,\n            isActive:         true,\n            owner:            msg.sender\n        });\n        allMicrogridHashes.push(hash);\n\n        // OTIMIZAÇÃO: Indexa a microgrid pela sua localização.\n        bytes32 locationHash = keccak256(abi.encodePacked(_country, _city));\n        microgridsByLocationHash[locationHash].push(hash);\n\n        emit MicrogridRegistered(hash, msg.sender, _country, _city);\n    }\n\n    /**\n     * @notice Envia dados de geração de energia de um sensor.\n     * @dev Apenas o dono do registro ou a carteira da microgrid podem enviar dados.\n     * @param hash O hash da microgrid.\n     * @param kWh A quantidade de energia gerada em kWh.\n     */\n    function submitSensorData(bytes32 hash, uint256 kWh) external {\n        Microgrid storage mg = microgridByHash[hash];\n        require(mg.isActive, \"Microgrid: Inativa\");\n        require(msg.sender == mg.owner || msg.sender == mg.walletMetamask, \"Microgrid: Nao autorizado\");\n        require(kWh > 0, \"Sensor: kWh deve ser maior que 0\");\n\n        sensorHistory[hash].push(SensorRecord(kWh, block.timestamp));\n        emit SensorDataSubmitted(hash, kWh, block.timestamp);\n    }\n\n    /*––––– FUNÇÕES DE NÓ –––––*/\n\n    /**\n     * @notice Registra um novo nó consumidor de energia.\n     * @param microgridHash O hash da microgrid inicial à qual o nó se conectará.\n     * @param country O país onde o nó está operando.\n     * @param city A cidade onde o nó está operando.\n     * @param initialGB A capacidade de armazenamento/processamento do nó.\n     */\n    function registerNode(\n        bytes32 microgridHash,\n        string  memory country,\n        string  memory city,\n        uint256 initialGB\n    ) external {\n        require(nodeByOperator[msg.sender].operator == address(0), \"Node: Ja existe\");\n        require(microgridByHash[microgridHash].isActive, \"Node: Microgrid inicial inativa\");\n\n        nodeByOperator[msg.sender] = Node({\n            operator:             msg.sender,\n            currentMicrogridHash: microgridHash,\n            isActive:             true,\n            country:              country,\n            city:                 city,\n            storedGB:             initialGB\n        });\n        allNodeOperators.push(msg.sender);\n        emit NodeRegistered(msg.sender, microgridHash);\n    }\n\n    /**\n     * @notice Verifica a energia da microgrid atual e, se abaixo de um limiar, troca para a melhor disponível na mesma cidade.\n     * @dev Se nenhuma microgrid adequada for encontrada, o nó é desativado.\n     */\n    function switchIfNeeded() external {\n        Node storage nd = nodeByOperator[msg.sender];\n        require(nd.isActive, \"Node: Inativo\");\n\n        uint256 requiredKWh = nd.storedGB * KWH_PER_GB;\n        uint256 currentKWh = latestSensor(nd.currentMicrogridHash).kWh;\n\n        if (currentKWh * 100 < requiredKWh * THRESHOLD_PCT) {\n            bytes32 locationHash = keccak256(abi.encodePacked(nd.country, nd.city));\n            bytes32[] storage candidates = microgridsByLocationHash[locationHash];\n\n            bytes32 bestAlternative;\n            uint256 maxKWh = 0;\n\n            // Loop otimizado: busca apenas nas microgrids da mesma cidade.\n            for (uint i = 0; i < candidates.length; i++) {\n                bytes32 candidateHash = candidates[i];\n                if (candidateHash == nd.currentMicrogridHash || !microgridByHash[candidateHash].isActive) {\n                    continue;\n                }\n\n                uint candidateKWh = latestSensor(candidateHash).kWh;\n                // Procura pela microgrid com mais energia, desde que atenda ao requisito.\n                if (candidateKWh >= requiredKWh && candidateKWh > maxKWh) {\n                    bestAlternative = candidateHash;\n                    maxKWh = candidateKWh;\n                }\n            }\n\n            if (bestAlternative != bytes32(0)) {\n                emit NodeSwitched(msg.sender, nd.currentMicrogridHash, bestAlternative);\n                nd.currentMicrogridHash = bestAlternative;\n            } else {\n                nd.isActive = false;\n                emit NodeDeactivated(msg.sender);\n            }\n        }\n    }\n\n    /*––––– FUNÇÕES DE LEITURA (VIEW) –––––*/\n\n    /**\n     * @notice Retorna o registro mais recente de um sensor de uma microgrid.\n     * @param hash O hash da microgrid.\n     * @return SensorRecord O último registro de energia.\n     */\n    function latestSensor(bytes32 hash) public view returns (SensorRecord memory) {\n        uint len = sensorHistory[hash].length;\n        if (len == 0) return SensorRecord(0, 0);\n        return sensorHistory[hash][len - 1];\n    }\n\n    /**\n     * @notice Retorna uma lista de microgrids ativas em uma determinada localização.\n     * @dev Função otimizada que busca por um índice de localização, economizando gás.\n     * @return hashes Array com os hashes das microgrids.\n     * @return wallets Array com as carteiras das microgrids.\n     * @return prices Array com os preços de energia.\n     * @return latestKWh Array com a última leitura de kWh de cada microgrid.\n     */\n    function microgridsByLocation(string calldata country, string calldata city)\n        external\n        view\n        returns (\n            bytes32[] memory hashes,\n            address[] memory wallets,\n            uint256[] memory prices,\n            uint256[] memory latestKWh\n        )\n    {\n        bytes32 locationHash = keccak256(abi.encodePacked(country, city));\n        bytes32[] storage hashesInLocation = microgridsByLocationHash[locationHash];\n        \n        uint count = hashesInLocation.length;\n        hashes    = new bytes32[](count);\n        wallets   = new address[](count);\n        prices    = new uint256[](count);\n        latestKWh = new uint256[](count);\n\n        for (uint i = 0; i < count; i++) {\n            bytes32 h = hashesInLocation[i];\n            Microgrid storage mg = microgridByHash[h];\n            \n            hashes[i]    = h;\n            wallets[i]   = mg.walletMetamask;\n            prices[i]    = mg.energyPricePerOp;\n            latestKWh[i] = latestSensor(h).kWh;\n        }\n    }\n\t/**\n \t * @notice Retorna uma lista com os hashes de todas as microgrids registradas.\n \t * @dev Útil para aplicações externas descobrirem todas as microgrids.\n \t */\n\tfunction listMicrogrids() external view returns (bytes32[] memory) {\n    \treturn allMicrogridHashes;\n\t}\n\n    /**\n     * @notice Retorna informações detalhadas sobre uma microgrid específica.\n     * @param hash O hash da microgrid.\n     * @return walletMetamask Endereço da carteira do operador.\n     * @return pricePerOp Preço da energia.\n     * @return country País de localização.\n     * @return city Cidade de localização.\n     * @return active Status da microgrid.\n     * @return latestKWh Última leitura de energia.\n     * @return capacityGB Capacidade de processamento equivalente em GB.\n     */\n    function getMicrogridInfo(bytes32 hash)\n        external\n        view\n        returns (\n            address walletMetamask,\n            uint256 pricePerOp,\n            string  memory country,\n            string  memory city,\n            bool    active,\n            uint256 latestKWh,\n            uint256 capacityGB\n        )\n    {\n        Microgrid storage mg = microgridByHash[hash];\n        require(mg.owner != address(0), \"Microgrid: Desconhecida\");\n        \n        uint256 kwh = latestSensor(hash).kWh;\n        \n        return (\n            mg.walletMetamask,\n            mg.energyPricePerOp,\n            mg.country,\n            mg.city,\n            mg.isActive,\n            kwh,\n            kwh / KWH_PER_GB\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}